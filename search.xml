<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于DPDK的多核令牌桶算法]]></title>
    <url>%2F2018%2F01%2F11%2F%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。其中限速就是一种QOS机制，目前限速算法中用得比较多的是令牌桶算法。本文不打算套路目前有哪些限速算法，而主要套路基于DPDK的软件架构，如何实现多核限速算法，并获取到较高的性能。 令牌桶算法介绍简介所谓的令牌桶算法，顾名思义，就是向一个桶中按照一定的速率放入令牌，如下图所示。当有需要限速的数据包通过的时候，依据数据报文的长度算出需要取走的令牌数N。如果桶中的令牌数量大于N，那么此数据包就顺利通过了限速测试。反之，此数据包就没有通过限速测试，于是就将报文进行丢弃处理（大多数情况下是如此，也可以进行其他处理，依赖用户程序的设计）。整个令牌桶算法的主要原理就是这样，是不是感觉很简单，详细分析将在下文介绍。 基于DPDK的实现首先介绍下DPDK的两个函数，这也是在算法的实现中需要用到的两个函数，摘抄自DPDK官方文档：12345static uint64_t rte_get_timer_cycles(void )Get the number of cycles since boot from the default timer.static uint64_t rte_get_timer_hz(void)Get the number of cycles in one second for the default timer. 放入令牌在本设计中，以N = rte_get_timer_hz() 的速率向桶里面放令牌。也就是说，每秒放入一秒的时钟周期个数的令牌。的限速rate = 10000Bps，需要限速的包的大小为1500B。那么在处理该数据包，应该消耗多少令牌呢？利用小学数学应该可以算出，需要消耗1234如果一秒内有一个包：N * (1500 / 10000) &lt; N 此时可以通过如果一秒内有7个包N * (1500*7 / 10000) &gt; N 那么第七个包将会被丢弃 放入方式假设每秒应该放入N = rte_get_timer_hz() 个令牌 方式1： 设置定时器，在定时器的回调函数中放入令牌。 解析： 可以利用dpdk的定时器，比如设置每1秒，call以下回调函数，放入令牌1 * N个令牌。 缺陷1： 这种方式的问题在于，如果在这一秒钟内，如果前0.5秒的突发流量将令牌都消耗完了，那么后0.5秒的报文不就全部丢掉了。有人说，可以将这个间隔设置小一点啊，比入每1/1000秒放入N/1000个令牌。但是问题在于，这个间隔到底是多少好呢？ 缺陷2： 无法处理突发流量，原因见方式3。 方式2： 按时间间隔放入 解析： 按时间间隔放入，假设当前报文和上一个报文的时间间隔为1ms秒，那么放入1/1000 * N 个令牌。这种方式的好处在于针对于每个数据包的处理前都会放入令牌，分散了令牌的放入。 缺陷： 无法处理突发流量，原因见方式3。 方式3： 改进方式2 背景： 方式1和方式2都面临一个问题，如果有突发流量，那么可能在极短的时间内消耗全部的令牌，大量的流量被放行，从而对系统造成威胁。 解析： 如果当出现丢包，那么在接下来的200us内的前64个报文都会被丢弃。对于200us和64这个值都是经验值，可以在真实场景中进行调优。 缺陷： 这个方式降低了突发流量对系统的威胁，但是会对限速的准确性有一定的影响，通过测试可以证明。 方式2和方式3可以协作运行，比如用方式3先进行防攻击限速，然后再用方式2进行精确限速。 多线程处理 多线程处理的基本思想，如下图所示： 一个全局令牌桶 随着时间的推移，每次放入令牌仅仅放入全局令牌桶。为什么不放入线程令牌桶？假设需要限速的报文到了不同的线程，并且每个线程流量不同，那么对于每个线程放入令牌的数量就不得而知了。 每个线程拥有独立的子令牌桶 子令牌桶只消费令牌，不放入令牌。当子令牌桶的令牌不够时，从全局令牌桶索取令牌。 详细流程 下面将用流程图的形式来描述多线程令牌桶的实现。在最后会介绍这种令牌桶算法可能存在的问题。]]></content>
      <categories>
        <category>网络转发</category>
      </categories>
      <tags>
        <tag>网络转发</tag>
        <tag>令牌桶算法</tag>
        <tag>多核限速</tag>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言构造函数]]></title>
    <url>%2F2018%2F01%2F10%2Fc%E8%AF%AD%E8%A8%80%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[说起这个属性，要从fio的vpp说起，引擎的注册函数fio_libaio_register与反注册函数fio_libaio_unregister都没有其他函数调用，而fio又没有以动态库的形式将这两个函数供别的地方使用,但是这两个函数有宏定义fio_init和fio_exit来修饰。这个两个个宏定义为：12#define fio_init __attribute__((constructor)) #define fio_exit __attribute__((destructor)) 以如下构造函数为例,这是vpp中的代码： 12345678910111213#define VLIB_DECLARE_INIT_FUNCTION(x, tag) \vlib_init_function_t * _VLIB_INIT_FUNCTION_SYMBOL (x, tag) = x; \static void __vlib_add_##tag##_function_##x (void) \ __attribute__((__constructor__)) ; \static void __vlib_add_##tag##_function_##x (void) \&#123; \ vlib_main_t * vm = vlib_get_main(); \ static _vlib_init_function_list_elt_t _vlib_init_function; \ _vlib_init_function.next_init_function \ = vm-&gt;tag##_function_registrations; \ vm-&gt;tag##_function_registrations = &amp;_vlib_init_function; \ _vlib_init_function.f = &amp;x; \&#125; 这个两个属性是gcc提供的属性，在dpdk中也有体现。若函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行。若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。通过如下测试代码，能更加清晰地认识到这两个属性的作用：123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void __attribute__((constructor)) con_func() &#123; printf("befor main: constructor is called..\n"); &#125; void __attribute__((destructor)) des_func() &#123; printf("after main: destructor is called..\n"); &#125; int main() &#123; printf("main func..\n"); return 0; &#125;结果：123befor main: constructor is called.. main func.. after main: destructor is called..]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ospf lsa理解（转）]]></title>
    <url>%2F2018%2F01%2F10%2Flsa%2F</url>
    <content type="text"><![CDATA[OSPF的区域类型和LSA类型这两个知识点，经常容易导致人们对他们理解上的混乱，今天就来谈谈这两个概念。本文将会以下面这个拓扑图为例进行讲解。 LSA Type，链路状态通告的类型本来想先讲区域类型，但是由于要理解不同类型的区域，必然要涉及到不同类型的LSA，现在把LSA放到前面先讲。我们这里谈谈常见的几种LSA：1、2、3、4、5、7类LSA。 1类LSA，路由器LSA。OSPF网络中所有路由器都会产生1类LSA，他的意思就是表示路由器自己在本区域内的直连链路信息。该LSA仅在本区域内传播。其中，Link ID跟ADV Router写的都是该路由器的RouterID。下图为1类LSA： 2类LSA，网络LSA。在广播或者非广播模式下（NBMA）由DR生成。该LSA仅在本区域内传播。2类LSA表达的意思应该是：某区域内，在广播或非广播的网段内选举了DR，于是DR在本区域范围利用2类LSA来进行通告。该LSA仅在本区域内传播。其中，该LSA的Link ID就是该DR的接口IP地址，而ADV Router则是DR的Router ID。 3类LSA，网络汇总LSA。由区域边界路由器ABR生成，用于将一个区域内的网络通告给OSPF中的其他区域。可以认为3类LSA保存着本区域以外的所有其他区域的网络。举个例子，在多区域的环境如1-0-2这样的三个区域，含有area1和area0的ABR会把area1的网络以3类LSA的形式通告给area0，当然它也会把area0里面的网络通告给area1。那么，area1里面的网络又是如何通告到area2呢？这里就要考虑到area1那些一开始被转换成3类LSA的网络，是如何进入到area2的问题了。当原先这个3类LSA进入到area0跟area2的边界路由器时，位于这个边界的ABR就把这条包含着area1链路信息的3类LSA进行修改，修改的内容是把里面的ADV Router替换成自己的Router ID，并且维持原先的Link ID不变，然后把这条修改后的LSA通告给area2，这个就是3类LSA的工作过程。 4类LSA，ASBR汇总LSA。4类LSA跟5类LSA是紧密联系在一起的，可以说4类LSA是由于5类LSA的存在而产生的。4类LSA由距离本路由器最近的ABR生成，这句话应该要这样来理解：如果路由器想要找到包含了外部路由的那台ASBR（自治系统边界路由器）的话，你应该要到达哪台ABR，这台ABR的Router ID就写在该LSA的ADV Router里面，而LSA里面的Link ID代表的是该ASBR的Router ID。 5类LSA，外部的LSA。5类LSA由包含了外部路由的ASBR产生，目标是把某外部路由通告给OSPF进程的所有区域（特殊区域除外，下面会提到）。5类LSA可以穿越所有区域，意思是在跨区域通告时，该LSA的Link ID和ADV Router一直保持不变。通俗一点来说，就像是该ASBR对OSPF全网络的所有路由器说，我有这个外部路由，想去的话就来找我吧！其中，Link ID代表的是那台ASBR所引入的网络，ADV Router则是该ASBR的Router ID。下图为5类LSA： 7类LSA7类LSA是一种由NSSA区域中引入了外部路由的路由器生成的LSA，他仅在NSSA本区域内传播。由于NSSA区域不允许外部的路由进来从而禁止了5类LSA，那么为了能够把自己的外部路由传播出去，于是使用了7类LSA来代替5类LSA的功能。值得注意的一点是，当这种7类LSA到达NSSA跟其他区域的边界后，该边界路由器会根据这条7类LSA。生成对应的5类LSA然后继续传播给其他区域。此时，这条5类的LSA里面的Link ID跟7类LSA一样，都是该外部网络地址，而ADV Router则变成了该边界路由器的Router ID，因为这条5类LSA本来就是边界路由器产生的。这里要注意的一点是，该5类LSA里面的Forwarding Address还是保持跟之前的7类LSA的Forwarding Address一样。 Area Type，区域类型OSPF的区域类型分为5种：Backbone area(area 0)、Standard area、Stub area、Totally stubby area、No so stubby area(NSSA)。下面来逐一介绍。 1、Backbone area也叫骨干区域，其实就是area 0。根据OSPF的设计原则，area 0在OSPF网络中起着中心节点的作用，其他区域的链路信息通过area 0来进行相互传递，这也意味着所有其他区域都必须跟area 0相连。该区域支持1、2、3、4、5类LSA。 2、Standard area也叫标准区域，标准区域的意思就是在这个区域里面可以正常传递OSPF各类报文。该区域支持1、2、3、4、5类LSA。 3、Stub area也叫末节区域，所谓末节区域，意思就是该区域不接受非OSPF网络的任何外部路由（external route），它如果要到达那些外部路由的时候，只需要通过默认路由把它发出去就可以了。该区域支持1、2、3类LSA。 4、Totally stubby area也叫完全末节区域，他的意思是该区域非但不接受外部路由，也不接受自己本区域以外的其他区域的链路信息。它如果要到达本区域以外的目标网络的时候，也是跟末节区域一样，直接把报文通过默认路由发出去。这里要注意的是，由于默认路由是用3类LSA发送的，所以完全末节区域虽然不允许普通的3类LSA报文，但是支持这种包含默认路由的3类LSA。该区域支持1、2类LSA，以及包含默认路由的3类LSA。 5、No so stubby area就是平时所说的NSSA了，这个NSSA其实是从stub区域发展而来的，它的意思是在含有stub区域的条件下，还拥有可以发送外部路由出去给其他区域的能力。该区域支持1、2、3、7类LSA。这里注意一点的是，NSSA区域还有另外一种模式，那就是是完全末节区域模式的NSSA。这个模式其实就是在完全末节区域环境下允许引入外部路由，这种区域模式支持1、2类LSA以及包含默认路由的3类LSA。 配置12area 24 stubarea 24 stub no-summary]]></content>
      <categories>
        <category>ospf</category>
      </categories>
      <tags>
        <tag>ospf</tag>
      </tags>
  </entry>
</search>
